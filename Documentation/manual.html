<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Box2D v2.1.0 User Manual</title><link rel="stylesheet" href="manual.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.66.0"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Box2D v2.1.0 User Manual</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Erin</span> <span class="surname">Catto</span></h3></div></div><div><p class="copyright">Copyright &copy; 2007-2009 Erin Catto</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#d0e15">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e18">1.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e28">1.2. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#d0e47">1.3. About this Manual</a></span></dt><dt><span class="sect1"><a href="#d0e52">1.4. Feedback and Reporting Bugs</a></span></dt><dt><span class="sect1"><a href="#d0e65">1.5. Core Concepts</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e137">2. Hello Box2D</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e147">2.1. Creating a World</a></span></dt><dt><span class="sect1"><a href="#d0e162">2.2. Creating a Ground Box</a></span></dt><dt><span class="sect1"><a href="#d0e219">2.3. Creating a Dynamic Body</a></span></dt><dt><span class="sect1"><a href="#d0e254">2.4. Simulating the World (of Box2D)</a></span></dt><dt><span class="sect1"><a href="#d0e295">2.5. Cleanup</a></span></dt><dt><span class="sect1"><a href="#d0e303">2.6. The Testbed</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e343">3. API Design</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e346">3.1. Memory Management</a></span></dt><dt><span class="sect1"><a href="#d0e386">3.2. Factories and Definitions</a></span></dt><dt><span class="sect1"><a href="#units">3.3. Units</a></span></dt><dt><span class="sect1"><a href="#d0e446">3.4. User Data</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e484">4. The World</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e487">4.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e498">4.2. Creating and Destroying a World</a></span></dt><dt><span class="sect1"><a href="#d0e511">4.3. Using a World</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e519">4.3.1. Simulation</a></span></dt><dt><span class="sect2"><a href="#d0e539">4.3.2. Exploring the World</a></span></dt><dt><span class="sect2"><a href="#d0e566">4.3.3. AABB Queries</a></span></dt><dt><span class="sect2"><a href="#d0e584">4.3.4. Ray Casts</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e598">5. Bodies</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e601">5.1. About</a></span></dt><dt><span class="sect1"><a href="#body_definition">5.2. Body Definition</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e649">5.2.1. Body Type</a></span></dt><dt><span class="sect2"><a href="#d0e656">5.2.2. Position and Angle</a></span></dt><dt><span class="sect2"><a href="#d0e679">5.2.3. Damping</a></span></dt><dt><span class="sect2"><a href="#d0e693">5.2.4. Sleep Parameters</a></span></dt><dt><span class="sect2"><a href="#d0e707">5.2.5. Fixed Rotation</a></span></dt><dt><span class="sect2"><a href="#d0e716">5.2.6. Bullets</a></span></dt><dt><span class="sect2"><a href="#d0e737">5.2.7. Activation</a></span></dt><dt><span class="sect2"><a href="#d0e748">5.2.8. User Data</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e758">5.3. Body Factory</a></span></dt><dt><span class="sect1"><a href="#d0e791">5.4. Using a Body</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e796">5.4.1. Mass Data</a></span></dt><dt><span class="sect2"><a href="#d0e813">5.4.2. State Information</a></span></dt><dt><span class="sect2"><a href="#d0e824">5.4.3. Position and Velocity</a></span></dt><dt><span class="sect2"><a href="#d0e839">5.4.4. Forces and Impulses</a></span></dt><dt><span class="sect2"><a href="#d0e850">5.4.5. Coordinate Transformations</a></span></dt><dt><span class="sect2"><a href="#d0e857">5.4.6. Lists</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e868">6. Shapes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e871">6.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e876">6.2. Abstract Shapes</a></span></dt><dt><span class="sect1"><a href="#d0e896">6.3. Circle Shapes</a></span></dt><dt><span class="sect1"><a href="#d0e899">6.4. Polygon Shapes</a></span></dt><dt><span class="sect1"><a href="#d0e902">6.5. Collision Functions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#fixtures">7. Fixtures</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e908">7.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e917">7.2. The Shape Definition</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e925">7.2.1. Friction and Restitution</a></span></dt><dt><span class="sect2"><a href="#d0e947">7.2.2. Density</a></span></dt><dt><span class="sect2"><a href="#d0e955">7.2.3. Filtering</a></span></dt><dt><span class="sect2"><a href="#d0e999">7.2.4. Sensors</a></span></dt><dt><span class="sect2"><a href="#d0e1008">7.2.5. Circle Definitions</a></span></dt><dt><span class="sect2"><a href="#d0e1020">7.2.6. Polygon Definitions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1060">7.3. Shape Factory</a></span></dt><dt><span class="sect1"><a href="#d0e1086">7.4. Using a Shape</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e1094">8. Joints</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e1097">8.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e1106">8.2. The Joint Definition</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1128">8.2.1. Distance Joint</a></span></dt><dt><span class="sect2"><a href="#d0e1144">8.2.2. Revolute Joint</a></span></dt><dt><span class="sect2"><a href="#d0e1187">8.2.3. Prismatic Joint</a></span></dt><dt><span class="sect2"><a href="#d0e1207">8.2.4. Pulley Joint</a></span></dt><dt><span class="sect2"><a href="#d0e1233">8.2.5. Gear Joint</a></span></dt><dt><span class="sect2"><a href="#d0e1260">8.2.6. Mouse Joint</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1265">8.3. Joint Factory</a></span></dt><dt><span class="sect1"><a href="#d0e1297">8.4. Using Joints</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1310">8.4.1. Using Distance Joints</a></span></dt><dt><span class="sect2"><a href="#d0e1315">8.4.2. Using Revolute Joints</a></span></dt><dt><span class="sect2"><a href="#d0e1336">8.4.3. Using Prismatic Joints</a></span></dt><dt><span class="sect2"><a href="#d0e1343">8.4.4. Using Pulley Joints</a></span></dt><dt><span class="sect2"><a href="#d0e1350">8.4.5. Using Gear Joints</a></span></dt><dt><span class="sect2"><a href="#d0e1358">8.4.6. Using Mouse Joints</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e1363">9. Contacts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e1366">9.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e1420">9.2. Contact Listener</a></span></dt><dt><span class="sect1"><a href="#d0e1469">9.3. Contact Filtering</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e1500">10. Loose Ends</a></span></dt><dd><dl><dt><span class="sect1"><a href="#world_boundary">10.1. World Boundary</a></span></dt><dt><span class="sect1"><a href="#implicit_destruction">10.2. Implicit Destruction</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e1575">11. Settings</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e1578">11.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e1591">11.2. Tolerances</a></span></dt><dt><span class="sect1"><a href="#d0e1598">11.3. Memory Allocation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e1623">12. Debug Drawing</a></span></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e15"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e18">1.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e28">1.2. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#d0e47">1.3. About this Manual</a></span></dt><dt><span class="sect1"><a href="#d0e52">1.4. Feedback and Reporting Bugs</a></span></dt><dt><span class="sect1"><a href="#d0e65">1.5. Core Concepts</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e18"></a>1.1.&nbsp;About</h2></div></div></div><p>Box2D is a 2D rigid body simulation library for games. Programmer's can use it in their games to make objects move in believable ways and make the game world more interactive. From the game's point of view a physics engine is just a system for procedural animation. Rather than paying (or begging) an animator to move your actors around, you can let Sir Isaac Newton do the directing.</p><p>Box2D is written in portable C++. Most of the types defined in the engine begin with the <span class="emphasis"><em>b2</em></span> prefix. Hopefully this is sufficient to avoid name clashing with your game engine.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e28"></a>1.2.&nbsp;Prerequisites</h2></div></div></div><p>In this manual I'll assume you are familiar with basic physics concepts, such as mass, force, torque, and impulses. If not, please first consult the many tutorials provided by Chris Hecker and David Baraff (google these names). You do not need to understand their tutorials in great detail, but they do a good job of laying out the basic concepts that will help you use Box2D.</p><p><a href="http://wikipedia.org" target="_top">Wikipedia</a> is also an excellent source of physics and mathematics knowledge. In some ways it is more useful than Google, because it has carefully crafted content.</p><p>This is not a prerequisite, but if you are curious about the about the inner workings of Box2D, you can look at these <a href="http://www.gphysics.com/downloads" target="_top">articles</a>.</p><p>Since Box2D is written in C++, you are expected to be experienced in C++ programming. Box2D should not be your first C++ programming project. You should be comfortable with compiling, linking, and debugging.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>Box2D should not be your first C++ project. Please learn C++ programming, compiling, linking, and debugging before working with Box2D. There are many resources for this on the net.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e47"></a>1.3.&nbsp;About this Manual</h2></div></div></div><p>This manual covers the majority of the Box2D API. However, not every aspect is covered. You are encouraged to look at the testbed included with Box2D to learn more. Also, the Box2D code base has comments formatted for Doxygen, so it is easy to create a hyper-linked API document.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e52"></a>1.4.&nbsp;Feedback and Reporting Bugs</h2></div></div></div><p>If you have feedback about anything related to Box2D, please leave a comment in the <a href="http://www.box2d.org/forum" target="_top">forum</a>. This is also a great place for community discussion.</p><p>If you have a bug or feature request, please file it here: <a href="http://code.google.com/p/box2d/issues/list" target="_top">issue tracker</a>. You can help to ensure your issue gets fixed if you provide sufficient detail. A testbed example that reproduces the problem is ideal.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e65"></a>1.5.&nbsp;Core Concepts</h2></div></div></div><p>Box2D works with several fundamental objects. We briefly define these objects here and more details are given later in this document.</p><div class="glosslist"><dl><dt>rigid body</dt><dd><p>A chunk of matter that is so strong that the distance between any two bits of matter on the chunk is completely constant. They are hard like a diamond. In the following discussion we use <span class="emphasis"><em>body</em></span> interchangably with rigid body.</p></dd><dt>shape</dt><dd><p>A 2D geometrical object, such as a circle or polygon.</p></dd><dt>fixture</dt><dd><p>A fixture binds a shape to a body and adds material properties such as density, friction, and restitution.</p></dd><dt>constraint</dt><dd><p>A constraint is a physical connection that removes degrees of freedom from bodies. In 2D a body has 3 degrees of freedom (two translation coordinates and one rotation coordinate). If we take a body and pin it to the wall (like a pendulum) we have <span class="emphasis"><em>constrained</em></span> the body to the wall. At this point the body can only rotate about the pin, so the constraint has removed 2 degrees of freedom.</p></dd><dt>contact constraint</dt><dd><p>A special constraint designed to prevent penetration of rigid bodies and to simulate friction and restitution. You do not create contact constraints, they are created automatically by Box2D.</p></dd><dt>joint</dt><dd><p>This is a contraint used to hold two or more bodies together. Box2D supports several joint types: revolute, prismatic, distance, and more. Some joints may have <span class="emphasis"><em>limits</em></span> and <span class="emphasis"><em>motors</em></span>.</p></dd><dt>joint limit</dt><dd><p>A joint limit restricts the range of motion of a joint. For example, the human elbow only allows a certain range of angles.</p></dd><dt>joint motor</dt><dd><p>A joint motor drives the motion of the connected bodies according to the joint's degrees of freedom. For example, you can use a motor to drive the rotation of an elbow.</p></dd><dt>world</dt><dd><p>A physics world is a collection of bodies, fixtures, and constraints that interact together. Box2D supports the creation of multiple worlds, but this is usually not necessary or desirable.</p></dd></dl></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e137"></a>Chapter&nbsp;2.&nbsp;Hello Box2D</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e147">2.1. Creating a World</a></span></dt><dt><span class="sect1"><a href="#d0e162">2.2. Creating a Ground Box</a></span></dt><dt><span class="sect1"><a href="#d0e219">2.3. Creating a Dynamic Body</a></span></dt><dt><span class="sect1"><a href="#d0e254">2.4. Simulating the World (of Box2D)</a></span></dt><dt><span class="sect1"><a href="#d0e295">2.5. Cleanup</a></span></dt><dt><span class="sect1"><a href="#d0e303">2.6. The Testbed</a></span></dt></dl></div><p>In the distribution of Box2D is a <span class="emphasis"><em>Hello World</em></span> project. The program creates a large ground box and a small dynamic box. This code does not contain any graphics, so prepare to be underwelmed. All you will see is text output in the console of the box's position over time.</p><p>This is a good example of how to get up and running with Box2D, more than the testbed.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e147"></a>2.1.&nbsp;Creating a World</h2></div></div></div><p>Every Box2D program begins with the creation of a b2World object. b2World is the physics hub that manages memory, objects, and simulation. You can allocate the physics world on the stack, heap, or data section. The decision is up to you.</p><p>It is easy to create a Box2D world. First, we define the gravity vector. Yes, you can make gravity go sideways (or you could just rotate your monitor). Also we tell the world to allow bodies to sleep when they come to rest. A sleeping body doesn't require any simulation.</p><pre class="programlisting">
b2Vec2 gravity(0.0f, -10.0f);
bool doSleep = true;
</pre><p>Now we create the world object. Note that we are creating the world on the stack, so the world must remain in scope.</p><pre class="programlisting">
b2World world(gravity, doSleep);
</pre><p>So now we have our physics world, let's start adding some stuff to it.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e162"></a>2.2.&nbsp;Creating a Ground Box</h2></div></div></div><p>Bodies are built using the following steps:</p><div class="orderedlist"><ol type="1"><li><p> Define a body with a position, damping, etc.</p></li><li><p> Use the world object to create the body.</p></li><li><p> Define fixtures with a shape, friction, density, etc.</p></li><li><p> Create fixtures on the body.</p></li></ol></div><p>For step 1 we create the ground body. For this we need a <span class="emphasis"><em>body definition</em></span>. With the body definition we specify the initial position of the ground body.</p><pre class="programlisting">
b2BodyDef groundBodyDef;
groundBodyDef.position.Set(0.0f, -10.0f);
</pre><p>For step 2 the body definition is passed to the world object to create the ground body. The world object does not keep a reference to the body definition. The ground body is created as a static body. Static bodies don't collide with other static bodies and are immovable. Box2D determines that a body is static when it has zero mass. Bodies have zero mass by default, therefore they are static by default.</p><pre class="programlisting">
b2Body* groundBody = world.CreateBody(&amp;groundBodyDef);
</pre><p>For step 3 we create a ground polygon. We use the <tt class="literal">SetAsBox</tt> shortcut to form the ground polygon into a box shape, with the box centered on the origin of the parent body.</p><pre class="programlisting">
b2PolygonShape groundBox;
groundBox.SetAsBox(50.0f, 10.0f);
</pre><p>The <tt class="function">SetAsBox</tt> function takes the half-width and half-height (extents). So in this case the ground box is 100 units wide (x-axis) and 20 units tall (y-axis). Box2D is tuned for meters, kilograms, and seconds. So you can consider the extents to be in meters. Box2D generally works best when objects are the size of typical real world objects. For example, a barrel is about 1 meter tall. Due to the limitations of floating point arithmetic, using Box2D to model the movement of glaciers or dust particles is not a good idea.</p><p>We finish the ground body in step 4 by creating the shape fixture. For this step we have a shortcut. We do not have a need to alter the default fixture material properties, so can pass the shape directly to the body without creating a fixture definition. Later we will see how to use a fixture definition for customized material properties.</p><pre class="programlisting">
groundBody-&gt;CreateFixture(&amp;groundBox);
</pre><p>Box2D does not keep a reference to the shape. It clones the data into a new <tt class="classname">b2Shape</tt> object.</p><p>Note that every fixture must have a parent body, even fixtures that are static. However, you can attach all static fixtures to a single static body. This need for static bodies is done to make the Box2D code more uniform internally, reducing the number of potential bugs.</p><p>You might notice a pattern here. Most Box2D types are prefixed with <tt class="literal">b2</tt>. This is done to reduce the chance for naming conflicts with your code.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e219"></a>2.3.&nbsp;Creating a Dynamic Body</h2></div></div></div><p>So now we have a ground body. We can use the same technique to create a dynamic body. The main difference, besides dimensions, is that we must establish the dynamic body's mass properties.</p><p>First we create the body using <tt class="function">CreateBody</tt>. By default bodies are static, so we should set the <tt class="classname">b2BodyType</tt> at construction time to make the body dynamic.</p><pre class="programlisting">
b2BodyDef bodyDef;
bodyDef.type = b2_dynamicBody;
bodyDef.position.Set(0.0f, 4.0f);
b2Body* body = world.CreateBody(&amp;bodyDef);
</pre><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>You must set the body type to <tt class="constant">b2_dynamicBody</tt> if you want the body to move in response to forces.</p></div><p>Next we create and attach a polygon shape using a fixture definition.First we create a box shape:</p><pre class="programlisting">
b2PolygonShape dynamicBox;
dynamicBox.SetAsBox(1.0f, 1.0f);
</pre><p>Next we create a fixture definition using the box. Notice that we set density to 1. The default density is zero. Also, the friction on the shape is set to 0.3. </p><pre class="programlisting">
b2FixtureDef fixtureDef;
fixtureDef.shape = &amp;dynamicBox;
fixtureDef.density = 1.0f;
fixtureDef.friction = 0.3f;
</pre><p>Using the fixture definition we can now create the fixture. This automatically updates the mass of the body. You can add as many fixtures as you like to a body. Each one contributes to the total mass.</p><pre class="programlisting">
body-&gt;CreateFixture(&amp;fixtureDef);
</pre><p>That's it for initialization. We are now ready to begin simulating.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e254"></a>2.4.&nbsp;Simulating the World (of Box2D)</h2></div></div></div><p>So we have initialized the ground box and a dynamic box. Now we are ready to set Newton loose to do his thing. We just have a couple more issues to consider.</p><p>Box2D uses a computational algorithm called an <span class="emphasis"><em>integrator</em></span>. Integrators simulate the physics equations at discrete points of time. This goes along with the traditional game loop where we essentially have a flip book of movement on the screen. So we need to pick a time step for Box2D. Generally physics engines for games like a time step at least as fast as 60Hz or 1/60 seconds. You can get away with larger time steps, but you will have to be more careful about setting up the definitions for your world. We also don't like the time step to change much. A variable time step produces variable results, which makes it difficult to debug. So don't tie the time step to your frame rate (unless you really, really have to). Without further ado, here is the time step.</p><pre class="programlisting">
float32 timeStep = 1.0f / 60.0f;
</pre><p>In addition to the integrator, Box2D also uses a larger bit of code called a <span class="emphasis"><em>constraint solver</em></span>. The constraint solver solves all the constraints in the simulation, one at a time. A single constraint can be solved perfectly. However, when we solve one constraint, we slightly disrupt other constraints. To get a good solution, we need to iterate over all constraints a number of times.</p><p>There are two phases in the constraint solver: a velocity phase and a position phase. In the velocity phase the solver computes the impulses necessary for the bodies to move correctly. In the position phase the solver adjusts the positions of the bodies to reduce overlap and joint detachment. Each phase has its own iteration count. In addition, the position phase may exit iteraions early if the errors are small.</p><p>The suggested iteration count for Box2D is 10 for both velocity and position. You can tune this number to your liking, just keep in mind that this has a trade-off between speed and accuracy. Using fewer iterations increases performance but accuracy suffers. Likewise, using more iterations decreases performance but improves the quality of your simulation. For this simple example, we don't need many iterations. Here are our chosen iteration counts.</p><pre class="programlisting">
int32 velocityIterations = 6;
int32 positionIterations = 2;
</pre><p>Note that the time step and the iteration count are completely unrelated. An iteration is not a sub-step. One iteration is a single pass over all the constraints within a time step. You can have multiple passes over the constraints within a single time step.</p><p>We are now ready to begin the simulation loop. In your game the simulation loop can be merged with your game loop. In each pass through your game loop you call <tt class="function">b2World::Step</tt>. Just one call is usually enough, depending on your frame rate and your physics time step. After stepping, you should call <tt class="function">b2World::ClearForces</tt> to clear any forces you applied to the bodies.</p><p>The Hello World program was designed to be dead simple, so it has no graphical output. Rather that being utterly boring by producing no output, the code prints out the position and rotation of the dynamic body. Yay! Here is the simulation loop that simulates 60 time steps for a total of 1 second of simulated time.</p><pre class="programlisting">
for (int32 i = 0; i &lt; 60; ++i)
{
    world.Step(timeStep, velocityIterations, positionIterations);
    world.ClearForces();
    b2Vec2 position = body-&gt;GetPosition();
    float32 angle = body-&gt;GetAngle();
    printf("%4.2f %4.2f %4.2f\n", position.x, position.y, angle);
}
</pre><p>The output shows the box falling and landing on the ground box. Your output should look like this:</p><pre class="programlisting">
0.00 4.00 0.00
0.00 3.99 0.00
0.00 3.98 0.00
...
0.00 1.25 0.00
0.00 1.13 0.00
0.00 1.01 0.00
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e295"></a>2.5.&nbsp;Cleanup</h2></div></div></div><p>When a world leaves scope or is deleted by calling <tt class="function">delete</tt> on a pointer, all the memory reserved for bodies, fixtures, and joints is freed. This is done to make your life easier. However, you will need to nullify any body, fixture, or joint pointers you have because they will become invalid.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e303"></a>2.6.&nbsp;The Testbed</h2></div></div></div><p>Once you have conquered the HelloWorld example, you should start looking at Box2D's testbed. The testbed is a unit-testing framework and demo environment. Here are some of the features:</p><div class="itemizedlist"><ul type="disc"><li><p> Camera with pan and zoom.</p></li><li><p> Mouse picking of shapes attached to dynamic bodies.</p></li><li><p> Extensible set of tests.</p></li><li><p> GUI for selecting tests, parameter tuning, and debug drawing options.</p></li><li><p> Pause and single step simulation.</p></li><li><p> Text rendering.</p></li></ul></div><div class="screenshot"><div class="mediaobject"><img src="images/testbed.gif"></div></div><p>The testbed has many examples of Box2D usage in the test cases and the framework itself. I encourage you to explore and tinker with the testbed as you learn Box2D.</p><p><span class="emphasis"><em>Note:</em></span> the testbed is written using <a href="http://freeglut.sourceforge.net/" target="_top">freeglut</a> and <a href="http://www.cs.unc.edu/~rademach/glui/" target="_top">GLUI</a>. The testbed is not part of the Box2D library. The Box2D library is agnostic about rendering. As shown by the HelloWorld example, you don't need a renderer to use Box2D.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e343"></a>Chapter&nbsp;3.&nbsp;API Design</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e346">3.1. Memory Management</a></span></dt><dt><span class="sect1"><a href="#d0e386">3.2. Factories and Definitions</a></span></dt><dt><span class="sect1"><a href="#units">3.3. Units</a></span></dt><dt><span class="sect1"><a href="#d0e446">3.4. User Data</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e346"></a>3.1.&nbsp;Memory Management</h2></div></div></div><p>A large number of the decisions about the design of Box2D were based on the need for quick and efficient use of memory. In this section I will discuss how and why Box2D allocates memory.</p><p>Box2D tends to allocate a large number of small objects (around 50-300 bytes). Using the system heap through <tt class="literal">malloc</tt> or <tt class="literal">new</tt> for small objects is inefficient and can cause fragmentation. Many of these small objects may have a short life span, such as contacts, but can persist for several time steps. So we need an allocator that can efficiently provide heap memory for these objects.</p><p>Box2D's solution is to use a <span class="emphasis"><em>small object</em></span> allocator (SOA). The SOA keeps a number of growable pools of varying sizes. When a request is made for memory, the SOA returns a block of memory that best fits the requested size. When a block is freed, it is returned to the pool. Both of these operations are fast and cause little heap traffic.</p><p>Since Box2D uses a SOA, you should never <span class="emphasis"><em>new</em></span> or <span class="emphasis"><em>malloc</em></span> a body, fixture, or joint. You do have to allocate a <tt class="classname">b2World</tt>. The <tt class="classname">b2World</tt> class provides factories for you to create bodies, fixtures, and joints. This allows Box2D to use the SOA and hide the gory details from you. Never, ever, call <tt class="literal">delete</tt> or <tt class="literal">free</tt> on a body, fixture, or joint.</p><p>While executing a time step, Box2D needs some temporary workspace memory. For this, it uses a stack allocator to avoid per-step heap allocations. You don't need to interact with the stack allocator, but it's good to know it's there.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e386"></a>3.2.&nbsp;Factories and Definitions</h2></div></div></div><p>As mentioned above, memory management plays a central role in the design of the Box2D API. So when you create a <tt class="classname">b2Body</tt> or a <tt class="classname">b2Joint</tt>, you need to call the factory functions on <tt class="classname">b2World</tt>.</p><p>There are creation functions:</p><pre class="programlisting">
b2Body* b2World::CreateBody(const b2BodyDef* def)
b2Joint* b2World::CreateJoint(const b2JointDef* def)
</pre><p>And there are corresponding destruction functions:</p><pre class="programlisting">
void b2World::DestroyBody(b2Body* body)
void b2World::DestroyJoint(b2Joint* joint)
</pre><p>When you create a body or joint, you need to provide a <span class="emphasis"><em>definition</em></span> or <span class="emphasis"><em>def</em></span> for short. These definitions contain all the information needed to build the body or joint. By using this approach we can prevent construction errors, keep the number of function parameters small, provide sensible defaults, and reduce the number of accessors.</p><p>Since fixtures musted be parented to a body, they are created and destroyed using a factory method on <tt class="classname">b2Body</tt>:</p><pre class="programlisting">
b2Fixture* b2Body::CreateFixture(const b2FixtureDef* def)
void b2Body::DestroyFixture(b2Fixture* fixture)
</pre><p>There is also shortcut to create a fixture directly from the shape and density.</p><pre class="programlisting">
b2Fixture* b2Body::CreateFixture(const b2Shape* shape, float32 density)
</pre><p>Factories do not retain references to the definitions. So you can create definitions on the stack and keep them in temporary resources.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="units"></a>3.3.&nbsp;Units</h2></div></div></div><p>Box2D works with floating point numbers, so some tolerances have to be used to make Box2D perform well. These tolerance have been tuned to work well with meters-kilogram-second (MKS) units. In particular, Box2D has been tuned to work well with moving objects between 0.1 and 10 meters. So this means objects between soup cans and buses in size should work well. Static objects may be up to 50 meters without too much trouble.</p><p>Being a 2D physics engine, it is tempting to use pixels as your units. Unfortunately this will lead to a poor simulation and possibly weird behavior. An object of length 200 pixels would be seen by Box2D as the size of a 45 story building. Imagine trying to simulate the movement of a high-rise building with an engine that is tuned to simulate ragdolls and barrels. It isn't pretty.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>Box2D is tuned for MKS units. Keep the size of moving objects roughly between 0.1 and 10 meters. You'll need to use some scaling system when you render your environment and actors. The Box2D examples do this by using an OpenGL viewport transform.</p></div><p>It is best to think of Box2D bodies as moving billboards upon which you attach your artwork. The billboard may move in a unit system of meters, but you can convert that to pixel coordinates with a simple scaling factor. You can then use those pixel coordinates to place your sprite, etc.</p><p>Box2D uses radians for angles. The body rotation is stored in radians and may grow unbounded. Consider normalizing the angle of your bodies if the magnitude of the angle becomes too large (use <tt class="literal">b2Body::SetAngle</tt>).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e446"></a>3.4.&nbsp;User Data</h2></div></div></div><p>The <tt class="classname">b2Fixture</tt>, <tt class="classname">b2Body</tt>, and <tt class="classname">b2Joint</tt> classes allow you to attach user data as a <tt class="literal">void</tt> pointer. This is handy when you are examining Box2D data structures and you want to determine how they relate to the data structures in your game engine.</p><p>For example, it is typical to attach an <span class="emphasis"><em>actor</em></span> pointer to the rigid body on that actor. This sets up a circular reference. If you have the actor, you can get the body. If you have the body, you can get the actor.</p><pre class="programlisting">
GameActor* actor = GameCreateActor();
b2BodyDef bodyDef;
bodyDef.userData = actor;
actor-&gt;body = box2Dworld-&gt;CreateBody(&amp;bodyDef);
</pre><p>Here are some examples of cases where you would need the user data:</p><div class="itemizedlist"><ul type="disc"><li><p>Applying damage to an actor using a collision result.</p></li><li><p>Playing a scripted event if the player is inside an axis-aligned box.</p></li><li><p>Accessing a game structure when Box2D notifies you that a joint is going to be destroyed.</p></li></ul></div><p>Keep in mind that user data is optional and you can put anything in it. However, you should be consistent. For example, if you want to store an actor pointer on one body, you should keep an actor pointer on all bodies. Don't store an actor pointer on one body, and a foo pointer on another body. This will likely lead to a crash if you try to cast an actor pointer into a foo pointer.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e484"></a>Chapter&nbsp;4.&nbsp;The World</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e487">4.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e498">4.2. Creating and Destroying a World</a></span></dt><dt><span class="sect1"><a href="#d0e511">4.3. Using a World</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e519">4.3.1. Simulation</a></span></dt><dt><span class="sect2"><a href="#d0e539">4.3.2. Exploring the World</a></span></dt><dt><span class="sect2"><a href="#d0e566">4.3.3. AABB Queries</a></span></dt><dt><span class="sect2"><a href="#d0e584">4.3.4. Ray Casts</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e487"></a>4.1.&nbsp;About</h2></div></div></div><p>The <tt class="classname">b2World</tt> class contains the bodies and joints. It manages all aspects of the simulation and allows for asynchronous queries (like AABB queries and ray-casts). Much of your interactions with Box2D will be with a <tt class="classname">b2World</tt> object.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e498"></a>4.2.&nbsp;Creating and Destroying a World</h2></div></div></div><p>Creating a world is fairly simple. You just need to provide a gravity vector and a Boolean indicating if bodies can sleep. Usually you will create and destory a world using <tt class="literal">new</tt> and <tt class="literal">delete</tt>.</p><pre class="programlisting">
b2World* myWorld = new b2World(gravity, doSleep);
... do stuff ...
delete myWorld;
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e511"></a>4.3.&nbsp;Using a World</h2></div></div></div><p>The world class contains factories for creating and destroying bodies and joints. These factories are discussed later in the sections on bodies and joints. There are some other interactions with <tt class="classname">b2World</tt> that I will cover now.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e519"></a>4.3.1.&nbsp;Simulation</h3></div></div></div><p>The world class is used to drive the simulation. You specify a time step and a velocity and position iteration count. For example:</p><pre class="programlisting">
float32 timeStep = 1.0f / 60.f;
int32 velocityIterations = 10;
int32 positionIterations = 8;
myWorld-&gt;Step(timeStep, velocityIterations, positionIterations);
</pre><p>After the time step you can examine your bodies and joints for information. Most likely you will grab the position off the bodies so that you can update your actors and render them. You can perform the time step anywhere in your game loop, but you should be aware of the order of things. For example, you must create bodies before the time step if you want to get collision results for the new bodies in that frame.</p><p>As I discussed above in the HelloWorld tutorial, you should use a fixed time step. By using a larger time step you can improve performance in low frame rate scenarios. But generally you should use a time step no larger than 1/30 seconds. A time step of 1/60 seconds will usually deliver a high quality simulation.</p><p>The iteration count controls how many times the constraint solver sweeps over all the contacts and joints in the world. More iterations always yields a better simulation. But don't trade a small time step for a large iteration count. 60Hz and 10 iterations is far better than 30Hz and 20 iterations.</p><p>After stepping, you should clear any forces you have applied to your bodies. This is done with the command <tt class="methodname">b2World::ClearForces</tt>. This lets you take multiple sub-steps with the same force field.</p><pre class="programlisting">
myWorld-&gt;ClearForces();
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e539"></a>4.3.2.&nbsp;Exploring the World</h3></div></div></div><p>The world is a container for bodies, contacts, and joints. You can grab the body, contact, and joint lists off the world and iterate over them. For example, this code wakes up all the bodies in the world:</p><pre class="programlisting">
for (b2Body* b = myWorld-&gt;GetBodyList(); b; b = b-&gt;GetNext())
{
    b-&gt;WakeUp();
}
</pre><p>Unfortunately real programs can be more complicated. For example, the following code is broken:</p><pre class="programlisting">
for (b2Body* b = myWorld-&gt;GetBodyList(); b; b = b-&gt;GetNext())
{
    GameActor* myActor = (GameActor*)b-&gt;GetUserData();
    if (myActor-&gt;IsDead())
    {
        myWorld-&gt;DestroyBody(b); // ERROR: now GetNext returns garbage.
    }
}
</pre><p>Everything goes ok until a body is destroyed. Once a body is destroyed, its next pointer becomes invalid. So the call to <tt class="methodname">b2Body::GetNext()</tt> will return garbage. The solution to this is to copy the next pointer before destroying the body.</p><pre class="programlisting">
b2Body* node = myWorld-&gt;GetBodyList();
while (node)
{
    b2Body* b = node;
    node = node-&gt;GetNext();
    
    GameActor* myActor = (GameActor*)b-&gt;GetUserData();
    if (myActor-&gt;IsDead())
    {
        myWorld-&gt;DestroyBody(b);
    }
}
</pre><p>This safely destroys the current body. However, you may want to call a game function that may destroy multiple bodies. In this case you need to be very careful. The solution is application specific, but for convenience I'll show one method of solving the problem.</p><pre class="programlisting">
b2Body* node = myWorld-&gt;GetBodyList();
while (node)
{
    b2Body* b = node;
    node = node-&gt;GetNext();
    
    GameActor* myActor = (GameActor*)b-&gt;GetUserData();
    if (myActor-&gt;IsDead())
    {
        bool otherBodiesDestroyed = GameCrazyBodyDestroyer(b);
        if (otherBodiesDestroyed)
        {
            node = myWorld-&gt;GetBodyList();
        }
    }
}
</pre><p>Obviously to make this work, <tt class="function">GameCrazyBodyDestroyer</tt> must be honest about what it has destroyed.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e566"></a>4.3.3.&nbsp;AABB Queries</h3></div></div></div><p>Sometimes you want to determine all the shapes in a region. The <tt class="classname">b2World</tt> class has a fast log(N) method for this using the <span class="emphasis"><em>broad-phase</em></span> data structure. You provide an AABB in world coordinates and an implementation of <tt class="classname">b2QueryCallback</tt>. The world calls your class with each fixture whose AABB overlaps the query AABB. Return true to the continue the query, otherwise return false. For example, the following code finds all the fixtures that potentially intersect a specified AABB and wakes up all of the associated bodies.</p><pre class="programlisting">
class MyQueryCallback : public b2QueryCallback
{
public:
    bool ReportFixture(b2Fixture* fixture)
    {
        b2Body* body = fixture-&gt;GetBody();
        body-&gt;WakeUp();
        
        // Return true to continue the query.
        return true;
    }
};

...

MyQueryCallback callback;
b2AABB aabb;
aabb.lowerBound.Set(-1.0f, -1.0f);
aabb.upperBound.Set(1.0f, 1.0f);
myWorld-&gt;Query(&amp;callback, aabb);
</pre><p>You cannot make any assumptions about the order of the callbacks.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e584"></a>4.3.4.&nbsp;Ray Casts</h3></div></div></div><p>You can use ray casts to do line-of-site checks, fire guns, etc. You perform a ray cast by implementing a callback class and providing the start and end points. The world class calls your class with each fixture hit by the ray. Your callback is provided with the fixture, the point of intersection, the unit normal vector, and the fractional distance along the ray. You cannot make any assumptions about the order of the callbacks.</p><p>You control the continuation of the ray cast by returning a fraction. Returning a fraction of zero indicates the ray cast should be terminated. A fraction of one indicates the ray cast should continue as if no hit occurred. And if you return the fraction from the argument list, the ray will be clipped to the current intersection point. So you can ray cast any shape, ray cast all shapes, or ray cast the closest shape by returning the appropriate fraction.</p><p>Here is an example:</p><pre class="programlisting">
// This class captures the closest hit shape.
class MyRayCastCallback : public b2RayCastCallback
{
public:
    MyRayCastCallback()
    {
        m_fixture = NULL;
    }
    
    float32 ReportFixture(b2Fixture* fixture, const b2Vec2&amp; point,
						const b2Vec2&amp; normal, float32 fraction)
    {
        m_fixture = fixture;
        m_point = point;
        m_normal = normal;
        m_fraction = fraction;
        return fraction;
    }
    
    b2Fixture* m_fixture;
    b2Vec2 m_point;
    b2Vec2 m_normal;
    float32 m_fraction;
};

MyRayCastCallback callback;
b2Vec2 point1(-1.0f, 0.0f);
b2Vec2 point2(3.0f, 1.0f);
myWorld-&gt;RayCast(&amp;callback, point1, point2);
</pre><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>Due to round-off errors, ray casts can sneak through small cracks between polygons in your static environment. If this is not acceptable in your application, please enlarge your polygons slightly.</p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e598"></a>Chapter&nbsp;5.&nbsp;Bodies</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e601">5.1. About</a></span></dt><dt><span class="sect1"><a href="#body_definition">5.2. Body Definition</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e649">5.2.1. Body Type</a></span></dt><dt><span class="sect2"><a href="#d0e656">5.2.2. Position and Angle</a></span></dt><dt><span class="sect2"><a href="#d0e679">5.2.3. Damping</a></span></dt><dt><span class="sect2"><a href="#d0e693">5.2.4. Sleep Parameters</a></span></dt><dt><span class="sect2"><a href="#d0e707">5.2.5. Fixed Rotation</a></span></dt><dt><span class="sect2"><a href="#d0e716">5.2.6. Bullets</a></span></dt><dt><span class="sect2"><a href="#d0e737">5.2.7. Activation</a></span></dt><dt><span class="sect2"><a href="#d0e748">5.2.8. User Data</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e758">5.3. Body Factory</a></span></dt><dt><span class="sect1"><a href="#d0e791">5.4. Using a Body</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e796">5.4.1. Mass Data</a></span></dt><dt><span class="sect2"><a href="#d0e813">5.4.2. State Information</a></span></dt><dt><span class="sect2"><a href="#d0e824">5.4.3. Position and Velocity</a></span></dt><dt><span class="sect2"><a href="#d0e839">5.4.4. Forces and Impulses</a></span></dt><dt><span class="sect2"><a href="#d0e850">5.4.5. Coordinate Transformations</a></span></dt><dt><span class="sect2"><a href="#d0e857">5.4.6. Lists</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e601"></a>5.1.&nbsp;About</h2></div></div></div><p>Bodies have position and velocity. You can apply forces, torques, and impulses to bodies. Bodies can be static, kinematic, or dynamic. Here are the body type defintions:</p><div class="glosslist"><dl><dt><tt class="constant">b2_staticBody</tt></dt><dd><p>A static body has does not move under simulation and behaves as if it has infinite mass. Internally, Box2D stores zero for the mass and the inverse mass. Static bodies can be moved manually by the user. A static body has zero velocity. Static bodies do not collide with other static or kinematic bodies.</p></dd><dt><tt class="constant">b2_kinematicBody</tt></dt><dd><p>A kinematic body moves under simulation according to its velocity. Kinematic bodies do not respond to forces. They can be moved manually by the user, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass, however, Box2D store zero for the mass and the inverse mass. Kinematic bodies do not collide with other static or kinematic bodies.</p></dd><dt><tt class="constant">b2_dynamicBody</tt></dt><dd><p>A dynamic body is fully simulated. They can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass. If you try to set the mass of a dynamic body to zero, it will automatically acquire a mass of one kilogram.</p></dd></dl></div><p>Bodies are the backbone for fixtures. Bodies carry fixtures and move them around in the world. Bodies are always <span class="emphasis"><em>rigid bodies</em></span> in Box2D. That means that two fixtures attached to the same rigid body never move relative to each other.</p><p>Fixtures have collision geometry and density. Normally, bodies acquire their mass properties from the fixtures. However, you can override the mass properties after a body is constructed. This is discussed below.</p><p>You usually keep pointers to all the bodies you create. This way you can query the body positions to update the positions of your graphical entities. You should also keep body pointers so you can destroy them when you are done with them.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="body_definition"></a>5.2.&nbsp;Body Definition</h2></div></div></div><p>Before a body is created you must create a body definition (<tt class="classname">b2BodyDef</tt>). You can create a body definition on the stack or build it into your game's data structures. The choice is up to you.</p><p>Box2D copies the data out of the body definition, it does not keep a pointer to the body definition. This means you can recycle a body definition to create multiple bodies.</p><p>Lets go over some of the key members of the body definition.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e649"></a>5.2.1.&nbsp;Body Type</h3></div></div></div><p>As discussed at the beginning of this chapter, there are three different body types: static, kinematic, and dynamic. You should establish the body type at creation because changing the body type later is expensive.</p><pre class="programlisting">
bodyDef.type = b2_dynamicBody;
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e656"></a>5.2.2.&nbsp;Position and Angle</h3></div></div></div><p>The body definition gives you the chance to initialize the position of the body on creation. This has far better performance than creating the body at the world origin and then moving the body.</p><p>A body has two main points of interest. The first point is the body's <span class="emphasis"><em>origin</em></span>. Fixtures and joints are attached relative to the body's origin. The second point of interest is the <span class="emphasis"><em>center of mass</em></span>. The center of mass is determined from mass distribution of the attached shapes or is explicitly set with <tt class="classname">b2MassData</tt>. Much of Box2D's internal computations use the center of mass position. For example <tt class="classname">b2Body</tt> stores the linear velocity for the center of mass.</p><p>When you are building the body definition, you may not know where the center of mass is located. Therefore you specify the position of the body's origin. You may also specify the body's angle in radians, which is not affected by the position of the center of mass. If you later change the mass properties of the body, then the center of mass may move on the body, but the origin position does not change and the attached shapes and joints do not move.</p><pre class="programlisting">
bodyDef.position.Set(0.0f, 2.0f);   // the body's origin position.
bodyDef.angle = 0.25f * b2_pi;      // the body's angle in radians.
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e679"></a>5.2.3.&nbsp;Damping</h3></div></div></div><p>Damping is used to reduce the world velocity of bodies. Damping is different than friction because friction only occurs with contact. Damping is not a replacement for friction and the two effects should be used together.</p><p>Damping parameters should be between 0 and infinity, with 0 meaning no damping, and infinity meaning full damping. Normally you will use a damping value between 0 and 0.1. I generally do not use linear damping because it makes bodies look <span class="emphasis"><em>floaty</em></span>.</p><pre class="programlisting">
bodyDef.linearDamping = 0.0f;
bodyDef.angularDamping = 0.01f;
</pre><p>Damping is approximated for stability and performance. At small damping values the damping effect is mostly independent of the time step. At larger damping values, the damping effect will vary with the time step. This is not an issue if you use a fixed time step (recommended).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e693"></a>5.2.4.&nbsp;Sleep Parameters</h3></div></div></div><p>What does sleep mean? Well it is expensive to simulate bodies, so the less we have to simulate the better. When a body comes to rest we would like to stop simulating it.</p><p>When Box2D determines that a body (or group of bodies) has come to rest, the body enters a sleep state which has very little CPU overhead. If an awake body collides with a sleeping body, then the sleeping body wakes up. Bodies will also wake up if a joint or contact attached to them is destroyed. You can also wake a body manually.</p><p>The body definition lets you specify whether a body can <span class="emphasis"><em>sleep</em></span> and whether a body is created sleeping.</p><pre class="programlisting">
bodyDef.allowSleep = true;
bodyDef.awake = true;
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e707"></a>5.2.5.&nbsp;Fixed Rotation</h3></div></div></div><p>You may want a rigid body, such as a character, to have a fixed rotation. Such a body should not rotate, even under load. You can use the fixed rotation setting to achieve this:</p><pre class="programlisting">
bodyDef.fixedRotation = true;
</pre><p>The fixed roation flag causes the rotational inertia and its inverse to be set to zero.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e716"></a>5.2.6.&nbsp;Bullets</h3></div></div></div><p>Game simulation usually generates a sequence of images that are played at some frame rate. This is called <span class="emphasis"><em>discrete simulation</em></span>. In discrete simulation, rigid bodies can move by a large amount in one time step. If a physics engine doesn't account for the large motion, you may see some objects incorrectly pass through each other. This effect is called <span class="emphasis"><em>tunneling</em></span>.</p><p>By default, Box2D uses continuous collision detection (CCD) to prevent dynamic bodies from tunneling through static bodies. This is done by sweeping shapes from their old position to their new positions. The engine looks for new collisions during the sweep and computes the time of impact (TOI) for these collisions. Bodies are moved to their first TOI and then simulated to the end of the original time step. This process is repeated as necessary.</p><p>Normally CCD is not used between dynamic bodies. This is done to keep performance reasonable. In some game scenarios you need dynamic bodies to use CCD. For example, you may want to shoot a high speed bullet at a stack of dynamic bricks. Without CCD, the bullet my tunnel through the bricks.</p><p>Fast moving objects in Box2D can be labeled as bullets. Bullets will perform CCD with both static and dynamic bodies. You should decide what bodies should be bullets based on your game design. If you decide a body should be treated as a bullet, use the following setting.</p><pre class="programlisting">
bodyDef.bullet = true;
</pre><p>The bullet flag only affects dynamic bodies. The body doesn't have to move fast for the bullet flag to be appropriate. For example, you may have a slowly moving door that you don't want any dynamic bodies to pass through. Just enable the bullet flag for the door and no dynamic bodies should pass through.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e737"></a>5.2.7.&nbsp;Activation</h3></div></div></div><p>You may wish a body to be create but not participate in collision or dynamics. This state is similar to sleeping except the body will not be woken by other bodies and the body's fixtures will not be placed in the broad-phase. This means the body will no participate in collisions, ray casts, etc.</p><p>You can create a body in an inactive state and later re-activate it.</p><pre class="programlisting">
bodyDef.active = true;
</pre><p>Joints may be connected to inactive bodies. These joints will not be simulated. You should be careful when you activate a body that its joints are not distorted.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e748"></a>5.2.8.&nbsp;User Data</h3></div></div></div><p>User data is a <span class="type">void</span> pointer. This gives you a hook to link your application objects to bodies. You should be consistent to use the same object type for all body user data.</p><pre class="programlisting">
b2BodyDef bodyDef;
bodyDef.userData = &amp;myActor;
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e758"></a>5.3.&nbsp;Body Factory</h2></div></div></div><p>Bodies are created and destroyed using a body factory provided by the world class. This lets the world create the body with an efficient allocator and add the body to the world data structure.</p><p>Bodies can be dynamic or static depending on the mass properties. Both body types use the same creation and destruction methods.</p><pre class="programlisting">
b2Body* dynamicBody = myWorld-&gt;CreateBody(&amp;bodyDef);
... do stuff ...
myWorld-&gt;DestroyBody(dynamicBody);
dynamicBody = NULL;
</pre><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p><span class="emphasis"><em>Never</em></span> use <tt class="literal">new</tt> or <tt class="literal">malloc</tt> to create a body. The world won't know about the body and the body won't be properly initialized.</p></div><p>Static bodies do not move under the influence of other bodies. You may manually move static bodies, but you should be careful so that you don't squash dynamic bodies between two or more static bodies. Friction will not work correctly if you move a static body. Static bodies never simulate on their own and they never collide with other static bodies. It is faster to attach several shapes to a static body than to create several static bodies with a single shape on each one. Interally, Box2D sets the mass and inverse mass of static bodies to zero. This makes the math work out so that most algorithms don't need to treat static bodies as a special case.</p><p>Box2D does not keep a reference to the body definition or any of the data it holds (except user data pointers). So you can create temporary body definitions and reuse the same body definitions.</p><p>Box2D allows you to avoid destroying bodies by deleting your <tt class="classname">b2World</tt> object, which does all the cleanup work for you. However, you should be mindful to nullify any body pointers that you keep in your game engine.</p><p>When you destroy a body, the attached shapes and joints are automatically destroyed. This has important implications for how you manage shape and joint pointers. See <a href="#implicit_destruction" title="10.2.&nbsp;Implicit Destruction">Section&nbsp;10.2, &#8220;Implicit Destruction&#8221;</a> for details.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e791"></a>5.4.&nbsp;Using a Body</h2></div></div></div><p>After creating a body, there are many operations you can perform on the body. These include setting mass properties, accessing position and velocity, applying forces, and transforming points and vectors.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e796"></a>5.4.1.&nbsp;Mass Data</h3></div></div></div><p>Every body has a mass (scalar), center of mass (2-vector), and rotational inertia (scalar). For static bodies, the mass and rotational inertia are set to zero. When a body has fixed rotation, it's rotational inertia is zero.</p><p>Normally the mass properties of a body are established automatically when fixtures are added to the body. You can also adjust the mass of a body at run-time. This is usually done when you have special game scenerios that require altering the mass.</p><pre class="programlisting">
void SetMassData(const b2MassData* data);
</pre><p>After setting a body's mass directly, you may wish to revert to the natural mass dictated by the fixtures. You can do this with:</p><pre class="programlisting">
void ResetMassData(const b2MassData* data);
</pre><p>The body's mass data is available through the following functions:</p><pre class="programlisting">
float32 GetMass() const;
float32 GetInertia() const;
const b2Vec2&amp; GetLocalCenter() const;
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e813"></a>5.4.2.&nbsp;State Information</h3></div></div></div><p>There are many aspects to the body's state. You can access this state data efficiently through the following functions:</p><pre class="programlisting">
void SetType(b2BodyType type);
b2BodyType GetType();

void SetBullet(bool flag);
bool IsBullet() const;

void SetSleepingAllowed(bool flag);
bool IsSleepingAllowed() const;

void SetAwake(bool flag);
bool IsAwake() const;

void SetActive(bool flag);
bool IsActive() const;

void SetFixedRotation(bool flag);
bool IsFixedRotation() const;
</pre><p>These states are describe here: <a href="#body_definition" title="5.2.&nbsp;Body Definition">Section&nbsp;5.2, &#8220;Body Definition&#8221;</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e824"></a>5.4.3.&nbsp;Position and Velocity</h3></div></div></div><p>You access the position and rotation of a body. This is common when rendering your associated game actor. You can also set the position, although this is less common since you will normally use Box2D to simulate movement.</p><pre class="programlisting">
bool SetTransform(const b2Vec2&amp; position, float32 angle);
const b2Transform&amp; GetTransform() const;
const b2Vec2&amp; GetPosition() const;
float32 GetAngle() const;
</pre><p>You can access the center of mass position in local and world coordinates. Much of the internal simulation in Box2D uses the center of mass. However, you should normally not need to access it. Instead you will usually work with the body transform. For example, you may have a body that is square. The body origin might be a corner of the square, while the center of mass is located at the center of the square.</p><pre class="programlisting">
const b2Vec2&amp; GetWorldCenter() const;
const b2Vec2&amp; GetLocalCenter() const;
</pre><p>You can access the linear and angular velocity. The linear velocity is for the center of mass.</p><pre class="programlisting">
void SetLinearVelocity(const b2Vec2&amp; v);
b2Vec2 GetLinearVelocity() const;
void SetAngularVelocity(float32 omega);
float32 GetAngularVelocity() const;
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e839"></a>5.4.4.&nbsp;Forces and Impulses</h3></div></div></div><p>You can apply forces, torques, and impulses to a body. When you apply a force or an impulse, you provide a world point where the load is applied. This often results in a torque about the center of mass.</p><pre class="programlisting">
void ApplyForce(const b2Vec2&amp; force, const b2Vec2&amp; point);
void ApplyTorque(float32 torque);
void ApplyImpulse(const b2Vec2&amp; impulse, const b2Vec2&amp; point);
</pre><p>Applying a force, torque, or impulse wakes the body. Sometimes this is undesirable. For example, you may be applying a steady force and want to allow the body to sleep to improve performance. In this case you can use the following code.</p><pre class="programlisting">
if (myBody-&gt;IsSleeping() == false)
{
    myBody-&gt;ApplyForce(myForce, myPoint);
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e850"></a>5.4.5.&nbsp;Coordinate Transformations</h3></div></div></div><p>The body class has some utility functions to help you transform points and vectors between local and world space. If you don't understand these concepts, please read "Essential Mathematics for Games and Interactive Applications" by Jim Van Verth and Lars Bishop. These functions are efficient (when inlined), so use them with impunity.</p><pre class="programlisting">
b2Vec2 GetWorldPoint(const b2Vec2&amp; localPoint);
b2Vec2 GetWorldVector(const b2Vec2&amp; localVector);
b2Vec2 GetLocalPoint(const b2Vec2&amp; worldPoint);
b2Vec2 GetLocalVector(const b2Vec2&amp; worldVector);
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e857"></a>5.4.6.&nbsp;Lists</h3></div></div></div><p>You can iterate over a body's fixtures. This is mainly useful if you need to access the fixture's user data.</p><pre class="programlisting">
for (b2Fixture* f = body-&gt;GetFixtureList(); f; f = f-&gt;GetNext())
{
    MyFixtureData* data = (MyFixtureData*)f-&gt;GetUserData();
    ... do something with data ...
}
</pre><p>You can similarly iterate over the body's joint list.</p><p>The body also provides a list of associated contacts. You can use this to get information about the current contacts. Be carefule, because the contact list may not contain all the contacts that existed during the previous time step.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e868"></a>Chapter&nbsp;6.&nbsp;Shapes</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e871">6.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e876">6.2. Abstract Shapes</a></span></dt><dt><span class="sect1"><a href="#d0e896">6.3. Circle Shapes</a></span></dt><dt><span class="sect1"><a href="#d0e899">6.4. Polygon Shapes</a></span></dt><dt><span class="sect1"><a href="#d0e902">6.5. Collision Functions</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e871"></a>6.1.&nbsp;About</h2></div></div></div><p>Shapes describe collision geometry and are normally attached to bodies using fixtures. However, you may also create shapes independent of bodies and the world object. You have access to all the low level collision algorithms that Box2D uses internally.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e876"></a>6.2.&nbsp;Abstract Shapes</h2></div></div></div><p>Box2D shapes implement the b2Shape base class. The base class has defines functions to:</p><div class="itemizedlist"><ul type="disc"><li><p>Test a point for overlap with the shape.</p></li><li><p>Perform a ray cast against the shape.</p></li><li><p>Compute the shape's AABB.</p></li><li><p>Compute the mass properties of the shape.</p></li></ul></div><p>In addition, each shape has a type member and a radius. The radius even applies to polygons, as discussed below.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e896"></a>6.3.&nbsp;Circle Shapes</h2></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e899"></a>6.4.&nbsp;Polygon Shapes</h2></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e902"></a>6.5.&nbsp;Collision Functions</h2></div></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="fixtures"></a>Chapter&nbsp;7.&nbsp;Fixtures</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e908">7.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e917">7.2. The Shape Definition</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e925">7.2.1. Friction and Restitution</a></span></dt><dt><span class="sect2"><a href="#d0e947">7.2.2. Density</a></span></dt><dt><span class="sect2"><a href="#d0e955">7.2.3. Filtering</a></span></dt><dt><span class="sect2"><a href="#d0e999">7.2.4. Sensors</a></span></dt><dt><span class="sect2"><a href="#d0e1008">7.2.5. Circle Definitions</a></span></dt><dt><span class="sect2"><a href="#d0e1020">7.2.6. Polygon Definitions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1060">7.3. Shape Factory</a></span></dt><dt><span class="sect1"><a href="#d0e1086">7.4. Using a Shape</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e908"></a>7.1.&nbsp;About</h2></div></div></div><p>Fixtures attach collision geometry (shapes) to bodies. Fixtures are also used to define the mass of a body. This lets you specify the density and let Box2D do the work of computing the mass properties.</p><p>Fixtures have properties of friction and restitution. Fixtures carry collision filtering information to let you prevent collisions between certain game objects.</p><p>Shapes are always owned by a body. You can attach multiple shapes to a single body. Shapes are abstract classes so that many types of shapes can be implemented in Box2D. If you are brave, you can implement your own shape type (and collision algorithms).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e917"></a>7.2.&nbsp;The Shape Definition</h2></div></div></div><p>Shape definitions are used to create shapes. There is common shape data held by <tt class="classname">b2ShapeDef</tt> and specific shape data held by derived classes.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e925"></a>7.2.1.&nbsp;Friction and Restitution</h3></div></div></div><p>Friction is used to make objects slide along each other realistically. Box2D supports static and dynamic friction, but uses the same parameter for both. Friction is simulated accurately in Box2D and the friction strength is proportional to the normal force (this is called <span class="emphasis"><em>Coulomb friction</em></span>). The friction parameter is usually set between 0 and 1. A value of zero turns off friction and a value of one makes the friction strong. When the friction is computed between two shapes, Box2D must combine the friction parameters of the two shapes. This is done with the following formula:</p><pre class="programlisting">
float32 friction;
friction = sqrtf(shape1-&gt;friction * shape2-&gt;friction);
</pre><p>Restitution is used to make objects bounce. The restitution value is usually set to be between 0 and 1. Consider dropping a ball on a table. A value of zero means the ball won't bounce. This is called an <span class="emphasis"><em>inelastic</em></span> collision. A value of one means the ball's velocity will be exactly reflected. This is called a <span class="emphasis"><em>perfectly elastic</em></span> collision. Restitution is combined using the following formula.</p><pre class="programlisting">
float32 restitution;
restitution = b2Max(shape1-&gt;restitution, shape2-&gt;restitution);
</pre><p>When a shape develops multiple contacts, restitution is simulated approximately. This is because Box2D uses an iterative solver. Box2D also uses inelastic collisions when the collision velocity is small. This is done to prevent jitter.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e947"></a>7.2.2.&nbsp;Density</h3></div></div></div><p>Box2D optionally computes the mass and rotational inertia of bodies using the mass distribution implied by the attached shapes. Specifying mass directly can often lead to poorly tuned simulations. Therefore, the recommended way of specifying body mass is by setting the shape densities and calling <tt class="literal">b2Body::SetMassFromShape</tt> once all the shapes are attached to the body.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e955"></a>7.2.3.&nbsp;Filtering</h3></div></div></div><p>Collision filtering is a system for preventing collision between shapes. For example, say you make a character that rides a bicycle. You want the bicycle to collide with the terrain and the character to collide with the terrain, but you don't want the character to collide with the bicycle (because they must overlap). Box2D supports such collision filtering using categories and groups.</p><p>Box2D supports 16 collision categories. For each shape you can specify which category it belongs to. You also specify what other categories this shape can collide with. For example, you could specify in a multiplayer game that all players don't collide with each other and monsters don't collide with each other, but players and monsters should collide. This is done with <span class="emphasis"><em>masking bits</em></span>. For example:</p><pre class="programlisting">
playerShapeDef.filter.categoryBits = 0x0002;
monsterShapeDef.filter.categoryBits = 0x0004;
playerShape.filter.maskBits = 0x0004;
monsterShapeDef.filter.maskBits = 0x0002;
</pre><p>Collision groups let you specify an integral group index. You can have all shapes with the same group index always collide (positive index) or never collide (negative index). Group indices are usually used for things that are somehow related, like the parts of a bicycle. In the following example, shape1 and shape2 always collide, but shape3 and shape4 never collide.</p><pre class="programlisting">
shape1Def.filter.groupIndex = 2;
shape2Def.filter.groupIndex = 2;
shape3Def.filter.groupIndex = -8;
shape4Def.filter.groupIndex = -8;
</pre><p>Collisions between shapes of different group indices are filtered according the category and mask bits. In other words, group filtering has higher precendence than category filtering.</p><p>Note that additional collision filtering occurs in Box2D. Here is a list:</p><div class="itemizedlist"><ul type="disc"><li><p> A shape on a static body never collides with a shape on another static body.</p></li><li><p> Shapes on the same body never collide with each other.</p></li><li><p> You can optionally enable/disable collision between shapes on bodies connected by a joint.</p></li></ul></div><p>Sometimes you might need to change collision filtering after a shape has already been created. You can get and set the <span class="structname">b2FilterData</span> structure on an existing shape using <tt class="function">b2Shape::GetFilterData</tt> and <tt class="function">b2Shape::SetFilterData</tt>. Box2D caches filtering results, so you must manually re-filter a shape using <tt class="function">b2World::Refilter</tt>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e999"></a>7.2.4.&nbsp;Sensors</h3></div></div></div><p>Some times game logic needs to know when two shapes overlap yet there should be no collision response. This is done by using sensors. A sensor is a shape that detects collision but does not produce a response.</p><p>You can flag any shape as being a sensor. Sensors may be static or dynamic. Remember that you may have multiple shapes per body and you can have any mix of sensors and solid shapes.</p><pre class="programlisting">
myShapeDef.isSensor = true;
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1008"></a>7.2.5.&nbsp;Circle Definitions</h3></div></div></div><p><tt class="classname">b2CircleDef</tt> extends <tt class="classname">b2ShapeDef</tt> and adds a radius and a local position.</p><pre class="programlisting">
b2CircleDef def;
def.radius = 1.5f;
def.localPosition.Set(1.0f, 0.0f);
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1020"></a>7.2.6.&nbsp;Polygon Definitions</h3></div></div></div><p><tt class="classname">b2PolyDef</tt> is used to implement convex polygons. They are a bit tricky to use correctly, so please read closely. The maximum vertex count is defined by <tt class="literal">b2_maxPolyVertices</tt> which is currently 8. If you need to use more vertices, you must modify <tt class="literal">b2_maxPolyVertices</tt> in <tt class="literal">b2Settings.h</tt>.</p><p>When you build a polygon definition you must specify the number of vertices you will use. The vertices must be specified in <span class="emphasis"><em>counter-clockwise</em></span> (CCW) order about the z-axis of a right-handed coordinate system. This might turn out to be clockwise on your screen, depending on your coordinate system conventions.</p><p>Polygons must be <span class="emphasis"><em>convex</em></span>. In other words, each vertex must point outwards to some degree. Finally, you must not overlap any vertices. Box2D will automatically close the loop.</p><div class="informalfigure"><div class="mediaobject"><img src="images/convex_concave.gif"></div></div><p>Here is an example of a polygon definition of a triangle:</p><pre class="programlisting">
b2PolygonDef triangleDef;
triangleDef.vertexCount = 3;
triangleDef.vertices[0].Set(-1.0f, 0.0f);
triangleDef.vertices[1].Set(1.0f, 0.0f);
triangleDef.vertices[2].Set(0.0f, 2.0f);
</pre><p>The vertices are defined in the coordinate system of the parent body. If you need to offset a polygon within the parent body, then just offset all the vertices.</p><p>For convenience, there are functions to initialize polygons as boxes. You can have either an axis-aligned box centered at the body origin or an oriented box offset from the body origin.</p><pre class="programlisting">
b2PolygonDef alignedBoxDef;
float32 hx = 1.0f; // half-width
float32 hy = 2.0f; // half-height
alignedBoxDef.SetAsBox(hx, hy);

b2PolygonDef orientedBoxDef;
b2Vec2 center(-1.5f, 0.0f);
float32 angle = 0.5f * b2_pi;
orientedBoxDef.SetAsBox(hx, hy, center, angle);
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1060"></a>7.3.&nbsp;Shape Factory</h2></div></div></div><p>Shapes are created by initializing a shape definition and then passing the definition to the parent body.</p><pre class="programlisting">
b2CircleDef circleDef;
circleDef.radius = 3.0f;
circleDef.density = 2.5f;
b2Shape* myShape = myBody-&gt;CreateShape(&amp;circleDef);
[optionally store shape pointer somewhere]
</pre><p>This creates the shape and attaches it to the body. You do not need to store the shape pointer since the shape will automatically be destroyed when the parent body is destroyed (see <a href="#implicit_destruction" title="10.2.&nbsp;Implicit Destruction">Section&nbsp;10.2, &#8220;Implicit Destruction&#8221;</a>).</p><p>After you finish adding shapes to a body, you may want to recompute the mass properties of the body based on the child shapes.</p><pre class="programlisting">
myBody-&gt;SetMassFromShapes();
</pre><p>This function is expensive, so you should only call it when necessary.</p><p>You can destroy a shape on the parent body easily. You may do this to model a breakable object. Otherwise you can just leave the shape alone and let the body destruction take care of destroying the attached shapes.</p><pre class="programlisting">
myBody-&gt;DestroyShape(myShape);
</pre><p>After removing shapes from a body, you may want to call <tt class="literal">SetMassFromShapes</tt> again.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1086"></a>7.4.&nbsp;Using a Shape</h2></div></div></div><p>There's not much to say here. You can get a shape's type and its parent body. You can also test a point to see if it is contained within the shape. Look at <tt class="literal">b2Shape.h</tt> for details.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e1094"></a>Chapter&nbsp;8.&nbsp;Joints</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e1097">8.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e1106">8.2. The Joint Definition</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1128">8.2.1. Distance Joint</a></span></dt><dt><span class="sect2"><a href="#d0e1144">8.2.2. Revolute Joint</a></span></dt><dt><span class="sect2"><a href="#d0e1187">8.2.3. Prismatic Joint</a></span></dt><dt><span class="sect2"><a href="#d0e1207">8.2.4. Pulley Joint</a></span></dt><dt><span class="sect2"><a href="#d0e1233">8.2.5. Gear Joint</a></span></dt><dt><span class="sect2"><a href="#d0e1260">8.2.6. Mouse Joint</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1265">8.3. Joint Factory</a></span></dt><dt><span class="sect1"><a href="#d0e1297">8.4. Using Joints</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1310">8.4.1. Using Distance Joints</a></span></dt><dt><span class="sect2"><a href="#d0e1315">8.4.2. Using Revolute Joints</a></span></dt><dt><span class="sect2"><a href="#d0e1336">8.4.3. Using Prismatic Joints</a></span></dt><dt><span class="sect2"><a href="#d0e1343">8.4.4. Using Pulley Joints</a></span></dt><dt><span class="sect2"><a href="#d0e1350">8.4.5. Using Gear Joints</a></span></dt><dt><span class="sect2"><a href="#d0e1358">8.4.6. Using Mouse Joints</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1097"></a>8.1.&nbsp;About</h2></div></div></div><p>Joints are used to constrain bodies to the world or to each other. Typical examples in games include ragdolls, teeters, and pulleys. Joints can be combined in many different ways to create interesting motions.</p><p>Some joints provide limits so you can control the range of motion. Some joint provide motors which can be used to drive the joint at a prescribed speed until a prescribed force/torque is exceeded.</p><p>Joint motors can be used in many ways. You can use motors to control position by specifying a joint velocity that is proportional to the difference between the actual and desired position. You can also use motors to simulate joint friction: set the joint velocity to zero and provide a small, but significant maximum motor force/torque. Then the motor will attempt to keep the joint from moving until the load becomes too strong.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1106"></a>8.2.&nbsp;The Joint Definition</h2></div></div></div><p>Each joint type has a definition that derives from <tt class="classname">b2JointDef</tt>. All joints are connected between two different bodies. One body may static. If you want to waste memory, then create a joint between two static bodies. :)</p><p>You can specify user data for any joint type and you can provide a flag to prevent the attached bodies from colliding with each other. This is actually the default behavior and you must set the <tt class="literal">collideConnected</tt> Boolean to allow collision between to connected bodies.</p><p>Many joint definitions require that you provide some geometric data. Often a joint will be defined by <span class="emphasis"><em>anchor points</em></span>. These are points fixed in the attached bodies. Box2D requires these points to be specified in local coordinates. This way the joint can be specified even when the current body transforms violate the joint constraint --- a common ocurrence when a game is saved and reloaded. Additionally, some joint definitions need to know the default relative angle between the bodies. This is necessary to constraint rotation correctly via joint limits or a fixed relative angle.</p><p>Initializing the geometric data can be tedious, so many joints have initialization functions that use the current body transforms to remove much of the work. However, these initialization functions should usually only be used for prototyping. Production code should define the geometry directly. This will make joint behavior more robust.</p><p>The rest of the joint definition data depends on the joint type. We cover these now.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1128"></a>8.2.1.&nbsp;Distance Joint</h3></div></div></div><p>One of the simplest joint is a distance joint which says that the distance between two points on two bodies must be constant. When you specify a distance joint the two bodies should already be in place. Then you specify the two <span class="emphasis"><em>anchor</em></span> points in world coordinates. The first anchor point is connected to body 1, and the second anchor point is connected to body 2. These points imply the length of the distance constraint.</p><div class="informalfigure"><div class="mediaobject"><img src="images/distanceJoint.gif"></div></div><p>Here is an example of a distance joint definition. In this case we decide to allow the bodies to collide.</p><pre class="programlisting">
b2DistanceJointDef jointDef;
jointDef.Initialize(myBody1, myBody2, worldAnchorOnBody1, worldAnchorOnBody2);
jointDef.collideConnected = true;
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1144"></a>8.2.2.&nbsp;Revolute Joint</h3></div></div></div><p>A revolute joint forces two bodies to share a common anchor point, often called a <span class="emphasis"><em>hinge point</em></span>. The revolute joint has a single degree of freedom: the relative rotation of the two bodies. This is called the <span class="emphasis"><em>joint angle</em></span>.</p><div class="informalfigure"><div class="mediaobject"><img src="images/revoluteJoint.gif"></div></div><p>To specify a revolute you need to provide two bodies and a single anchor point in world space. The initialization function assumes that the bodies are already in the correct position.</p><p>In this example, two bodies are connected by a revolute joint at the first body's center of mass.</p><pre class="programlisting">
b2RevoluteJointDef jointDef;
jointDef.Initialize(myBody1, myBody2, myBody1-&gt;GetWorldCenter());
</pre><p>The revolute joint angle is positive when body2 rotates CCW about the angle point. Like all angles in Box2D, the revolute angle is measured in radians. By convention the revolute joint angle is zero when the joint is created using <tt class="literal">Initialize()</tt>, regardless of the current rotation of the two bodies.</p><p>In some cases you might wish to control the joint angle. For this, the revolute joint can optionally simulate a joint limit and/or a motor.</p><p>A joint limit forces the joint angle to remain between an lower and upper bound. The limit will apply as much torque as needed to make this happen. The limit range should include zero, otherwise the joint will lurch when the simulation begins.</p><p>A joint motor allows you to specify the joint speed (the time derivative of the angle). The speed can be negative or positive. A motor can have infinite force, but this is usually not desirable. Have you ever heard the expression:</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>"What happens when an irresistible force meets an immovable object?"</p></div><p>I can tell you it's not pretty. So you can provide a maximum torque for the joint motor. The joint motor will maintain the specified speed unless the required torque exceeds the specified maximum. When the maximum torque is exceeded, the joint will slow down and can even reverse.</p><p>You can use a joint motor to simulate joint friction. Just set the joint speed to zero, and set the maximum torque to some small, but significant value. The motor will try to prevent the joint from rotating, but will yield to a significant load.</p><p>Here's a revision of the revolute joint definition above; this time the joint has a limit and a motor enabled. The motor is setup to simulate joint friction.</p><pre class="programlisting">
b2RevoluteJointDef jointDef;
jointDef.Initialize(body1, body2, myBody1-&gt;GetWorldCenter());
jointDef.lowerAngle = -0.5f * b2_pi; // -90 degrees
jointDef.upperAngle = 0.25f * b2_pi; // 45 degrees
jointDef.enableLimit = true;
jointDef.maxMotorTorque = 10.0f;
jointDef.motorSpeed = 0.0f;
jointDef.enableMotor = true;
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1187"></a>8.2.3.&nbsp;Prismatic Joint</h3></div></div></div><p>A prismatic joint allows for relative translation of two bodies along a specified axis. A prismatic joint prevents relative rotation. Therefore, a prismatic joint has a single degree of freedom.</p><div class="informalfigure"><div class="mediaobject"><img src="images/prismaticJoint.gif"></div></div><p>The prismatic joint definition is similar to the revolute joint description; just substitute translation for angle and force for torque. Using this analogy provides an example prismatic joint definition with a joint limit and a friction motor:</p><pre class="programlisting">
b2PrismaticJointDef jointDef;
b2Vec2 worldAxis(1.0f, 0.0f);
jointDef.Initialize(myBody1, myBody2, myBody1-&gt;GetWorldCenter(), worldAxis);
jointDef.lowerTranslation = -5.0f;
jointDef.upperTranslation = 2.5f;
jointDef.enableLimit = true;
jointDef.motorForce = 1.0f;
jointDef.motorSpeed = 0.0f;
jointDef.enableMotor = true;
</pre><p>The revolute joint has an implicit axis coming out of the screen. The prismatic joint needs an explicit axis parallel to the screen. This axis is fixed in the two bodies and follows their motion.</p><p>Like the revolute joint, the prismatic joint translation is zero when the joint is created using <tt class="literal">Initialize()</tt>. So be sure zero is between your lower and upper translation limits.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1207"></a>8.2.4.&nbsp;Pulley Joint</h3></div></div></div><p>A pulley is used to create an idealized pulley. The pulley connects two bodies to ground and to each other. As one body goes up, the other goes down. The total length of the pulley rope is conserved according to the initial configuration.</p><pre class="programlisting">
length1 + length2 == constant
        </pre><div class="informalfigure"><div class="mediaobject"><img src="images/pulleyJoint.gif"></div></div><p>You can supply a ratio that simulates a <span class="emphasis"><em>block and tackle</em></span>. This causes one side of the pulley to extend faster than the other. At the same time the constraint force is smaller on one side than the other. You can use this to create mechanical leverage.</p><pre class="programlisting">
length1 + ratio * length2 == constant
        </pre><p>For example, if the ratio is 2, then length1 will vary at twice the rate of length2. Also the force in the rope attached to body1 will have half the constraint force as the rope attached to body2.</p><p>Pulleys can be troublesome when one side is fully extended. The rope on the other side will have zero length. At this point the constraint equations become singular (bad). Therefore the pulley joint constrains the maximum length that either side can attain. Also, you may want to control the maximum lengths for gameplay reasons. So the maximum lengths improve stability and give you more control.</p><p>Here is an example pulley definition:</p><pre class="programlisting">
b2Vec2 anchor1 = myBody1-&gt;GetWorldCenter();
b2Vec2 anchor2 = myBody2-&gt;GetWorldCenter();
b2Vec2 groundAnchor1(p1.x, p1.y + 10.0f);
b2Vec2 groundAnchor2(p2.x, p2.y + 12.0f);
float32 ratio = 1.0f;
b2PulleyJointDef jointDef;
jointDef.Initialize(myBody1, myBody2, groundAnchor1, groundAnchor2, anchor1, anchor2, ratio);
jointDef.maxLength1 = 18.0f;
jointDef.maxLength2 = 20.0f;
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1233"></a>8.2.5.&nbsp;Gear Joint</h3></div></div></div><p>If you want to create a sophisticated mechanical contraption you might want to use a gears. In principle you can create gears in Box2D by using compound shapes to model gear teeth. This is not very efficient and might be tedious to author. You also have to be careful to line up the gears so the teeth mesh smoothly. Box2D has a simpler method of creating gears: the <span class="emphasis"><em>gear joint</em></span>.</p><div class="informalfigure"><div class="mediaobject"><img src="images/gearJoint.gif"></div></div><p>The gear joint requires the you have two bodies connected to ground by a revolute or prismatic joint. You can use any combination of those joint types. Also, Box2D requires that the revolute and prismatic joints were created with the ground as body1.</p><p>Like the pulley ratio, you can specify a gear ratio. However, in this case the gear ratio can be negative. Also keep in mind that when one joint is a revolute joint (angular) and the other joint is prismatic (translation), then the gear ratio with have units of length or one over length.</p><pre class="programlisting">
coordinate1 + ratio * coordinate2 == constant
        </pre><p>Here is an example gear joint:</p><pre class="programlisting">
b2GearJointDef jointDef;
jointDef.body1 = myBody1;
jointDef.body2 = myBody2;
jointDef.joint1 = myRevoluteJoint;
jointDef.joint2 = myPrismaticJoint;
jointDef.ratio = 2.0f * b2_pi / myLength;
</pre><p>Note that the gear joint depends on two other joints. This creates a fragile situation. What happens if those joints are deleted?</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>Always delete gear joints before the revolute/prismatic joints on the gears. Otherwise your code will crash in a bad way due to the orphaned joint pointers in the gear joint. You should also delete the gear joint before you delete any of the bodies involved.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1260"></a>8.2.6.&nbsp;Mouse Joint</h3></div></div></div><p>The mouse joint is used in the testbed to manipulate bodies with the mouse. Please see the testbed and b2MouseJoint.h for details.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1265"></a>8.3.&nbsp;Joint Factory</h2></div></div></div><p>Joints are created and destroyed using the world factory methods. This brings up an old issue:</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>Don't try to create a body or joint on the stack or on the heap using <tt class="literal">new</tt> or <tt class="literal">malloc</tt>. You must create and destroy bodies and joints using the create and destroy methods of the <tt class="classname">b2World</tt> class.</p></div><p>Here's an example of the lifetime of a revolute joint:</p><pre class="programlisting">
b2RevoluteJointDef jointDef;
jointDef.body1 = myBody1;
jointDef.body2 = myBody2;
jointDef.anchorPoint = myBody1-&gt;GetCenterPosition();
b2RevoluteJoint* joint = myWorld-&gt;CreateJoint(&amp;jointDef);
... do stuff ...
myWorld-&gt;DestroyJoint(joint);
joint = NULL;
</pre><p>It is always good to nullify your pointer after they are destroyed. This will make the program crash in a controlled manner if you try to reuse the pointer.</p><p>The lifetime of a joint is not simple. Heed this warning well:</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>Joints are destroyed when an attached body is destroyed.</p></div><p>This precaution is not always necessary. You may organize your game engine so that joints are always destroyed before the attached bodies. In this case you don't need to implement the listener class. See <a href="#implicit_destruction" title="10.2.&nbsp;Implicit Destruction">Section&nbsp;10.2, &#8220;Implicit Destruction&#8221;</a> for details.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1297"></a>8.4.&nbsp;Using Joints</h2></div></div></div><p>Many simulations create the joints and don't access them again until they are detroyed. However, there is a lot of useful data contained in joints that you can use to create a rich simulation.</p><p>First of all, you can get the bodies, anchor points, and user data from a joint.</p><pre class="programlisting">
b2Body* GetBody1();
b2Body* GetBody2();
b2Vec2 GetAnchor1();
b2Vec2 GetAnchor2();
void* GetUserData();
</pre><p>All joints have a reaction force and torque. This the reaction force applied to body 2 at the anchor point. You can use reaction forces to break joints or trigger other game events. These functions may do some computations, so don't call them if you don't need the result.</p><pre class="programlisting">
b2Vec2 GetReactionForce();
float32 GetReactionTorque();
</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1310"></a>8.4.1.&nbsp;Using Distance Joints</h3></div></div></div><p>Distance joints don't have motors or limits, so there are no extra runtime methods for distance joints.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1315"></a>8.4.2.&nbsp;Using Revolute Joints</h3></div></div></div><p>You can access a revolute joint's angle, speed, and motor torque.</p><pre class="programlisting">
float32 GetJointAngle() const;
float32 GetJointSpeed() const;
float32 GetMotorTorque() const;
</pre><p>You also update the motor parameters each step.</p><pre class="programlisting">
void SetMotorSpeed(float32 speed);
void SetMaxMotorTorque(float32 torque);
</pre><p>Joint motors have some interesting abilities. You can update the joint speed every time step so you can make the joint move back-and-forth like a sine-wave or according to whatever function you want.</p><pre class="programlisting">
... Game Loop Begin ...
myJoint-&gt;SetMotorSpeed(cosf(0.5f * time));
... Game Loop End ...
</pre><p>You can also use joint motors to track a desired joint angle. For example:</p><pre class="programlisting">
... Game Loop Begin ...
float32 angleError = myJoint-&gt;GetJointAngle() - angleTarget;
float32 gain = 0.1f;
myJoint-&gt;SetMotorSpeed(-gain * angleError);
... Game Loop End ...
</pre><p>Generally your gain parameter should not be too large. Otherwise your joint may become unstable.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1336"></a>8.4.3.&nbsp;Using Prismatic Joints</h3></div></div></div><p>Using a prismatic joint is similar to using a revolute joint. Here are the relevant member functions:</p><pre class="programlisting">
float32 GetJointTranslation() const;
float32 GetJointSpeed() const;
float32 GetMotorForce() const;
void SetMotorSpeed(float32 speed);
void SetMotorForce(float32 force);
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1343"></a>8.4.4.&nbsp;Using Pulley Joints</h3></div></div></div><p>Pully joints provide the current lengths.</p><pre class="programlisting">
float32 GetLength1() const;
float32 GetLength2() const;
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1350"></a>8.4.5.&nbsp;Using Gear Joints</h3></div></div></div><p>Gear joints don't provide any information beyond the functions defined in <tt class="classname">b2Joint</tt>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1358"></a>8.4.6.&nbsp;Using Mouse Joints</h3></div></div></div><p>The mouse joint is able to manipulate the attached body by updating the target point each time step.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e1363"></a>Chapter&nbsp;9.&nbsp;Contacts</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e1366">9.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e1420">9.2. Contact Listener</a></span></dt><dt><span class="sect1"><a href="#d0e1469">9.3. Contact Filtering</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1366"></a>9.1.&nbsp;About</h2></div></div></div><p>Contacts are objects created by Box2D to manage collision between shapes. There are different kinds of contacts, derived from <tt class="classname">b2Contact</tt>, for managing contact between different kinds of shapes. For example there is a contact class for managing polygon-polygon collision and another contact class for managing circle-circle collision. This is normally not important to you, I just thought you might like to know.</p><p>Here is some terminlogy associated with contacts. This terminology is particular to Box2D, but you might find similar terminology in other physics engines.</p><div class="glosslist"><dl><dt>contact point</dt><dd><p>A contact point is a point where two shapes touch. In reality objects may touch over regions when surfaces touch. Box2D approximates contact with a small number of points.</p></dd><dt>contact normal</dt><dd><p>A contact normal is a unit vector that points from shape1 to shape2.</p></dd><dt>contact separation</dt><dd><p>Separation is the opposite of penetration. Separation is negative when shapes overlap. It is possible that future versions of Box2D will create contact points with positive separation, so you may want to check the sign when contact points are reported.</p></dd><dt>normal force</dt><dd><p>Box2D use an iterative contact solver and stores the results with the contact points. You can safely use the normal force to guage the collision intensity. For example, you can use the force to trigger breakables or to play collision sounds.</p></dd><dt>tangent force</dt><dd><p>The tangent force is the contact solver's estimate of the friction force.</p></dd><dt>contact ids</dt><dd><p>Box2D tries to re-use the contact force results from a time step as the initial guess for the next time step. Box2D uses contact ids to match contact points across time steps. The ids contain geometric features indices that help to distinguish one contact point from another.</p></dd></dl></div><p>Contacts are created when two shape's AABBs overlap. Sometimes collision filtering will prevent the creation of contacts. Box2D sometimes needs to create a contact even though the collision is filtered. In this case it uses a <tt class="classname">b2NullContact</tt> that prevents collision from occuring. Contacts are destroyed with the AABBs cease to overlap.</p><p>So you might gather that there may be contacts created for shapes that are not touching (just their AABBs). Well, this is correct. It's a "chicken or egg" problem. We don't know if we need a contact object until one is created to analyze the collision. We could delete the contact right away if the shapes are not touching, or we can just wait until the AABBS stop overlapping. Box2D takes the latter approach.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1420"></a>9.2.&nbsp;Contact Listener</h2></div></div></div><p>You can receive contact data by implementing <tt class="classname">b2ContactListener</tt>. This listener reports a contact point when it is created, when it persists for more than one time step, and when it is destroyed. Keep in mind that two shapes may have multiple contact points.</p><pre class="programlisting">
class MyContactListener : public b2ContactListener
{
public:
	void Add(const b2ContactPoint* point)
    {
        // handle add point
    }
    
	void Persist(const b2ContactPoint* point)
    {
        // handle persist point
    }
    
	void Remove(const b2ContactPoint* point)
    {
        // handle remove point
    }
    
    void Result(const b2ContactResult* point)
    {
        // handle results
    }
};</pre><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>Do not keep a reference to the contact points returned to <tt class="classname">b2ContactListener</tt>.
            Instead make a deep copy of the contact point data into your own buffer. The example below shows one way of doing this.</p></div><p>Continuous physics uses sub-stepping, so a contact point may be added and removed within the same time step. This is normally not a problem, but your code should handle this gracefully.</p><p>Contact points are reported immediately when they are added, persisted, or removed. This occurs before the solver is called, so the <span class="structname">b2ContactPoint</span> object does not contain the computed impulse. However, the relative velocity at the contact point is provided so that you can estimated the contact impulse. If you implement the <tt class="function">Result</tt> listener function, you will receive <span class="structname">b2ContactResult</span> objects for solid contact points after the solver has been called. These result structures contain the sub-step impulses. Again, due to continuous physics you may receive multiple results per contact point per <tt class="function">b2World::Step</tt>.</p><p>It is tempting to implement game logic that alters the physics world inside a contact callback. For example, you may have a collision that applies <span class="emphasis"><em>damage</em></span> and try to destroy the associated actor and its rigid body. However, Box2D does not allow you to alter the physics world inside a callback because you might destroy objects that Box2D is currently processing, leading to orphaned pointers. </p><p>The recommended practice for processing contact points is to buffer all contact points that you care about and process them after the time step. You should always process the contact points immediately after the time step, otherwise some other client code might alter the physics world, invalidating the contact buffer. When you process the contact point buffer you can alter the physics world, but you still need to be careful that you don't orphan pointers stored in the contact point buffer. The testbed has example contact point processing that is safe from orphaned pointers.</p><p>This code from the CollisionProcessing test shows how to handle orphaned bodies when processing the contact buffer. Here is an excerpt. Be sure to read the comments in the listing. This code assumes that all contact points have been buffered in the <tt class="classname">b2ContactPoint</tt> array <tt class="varname">m_points</tt>.</p><pre class="programlisting">
// We are going to destroy some bodies according to contact
// points. We must buffer the bodies that should be destroyed
// because they may belong to multiple contact points.
const int32 k_maxNuke = 6;
b2Body* nuke[k_maxNuke];
int32 nukeCount = 0;

// Traverse the contact buffer. Destroy bodies that
// are touching heavier bodies.
for (int32 i = 0; i &lt; m_pointCount; ++i)
{
    ContactPoint* point = m_points + i;

    b2Body* body1 = point-&gt;shape1-&gt;GetBody();
    b2Body* body2 = point-&gt;shape2-&gt;GetBody();
    float32 mass1 = body1-&gt;GetMass();
    float32 mass2 = body2-&gt;GetMass();

    if (mass1 &gt; 0.0f &amp;&amp; mass2 &gt; 0.0f)
    {
        if (mass2 &gt; mass1)
        {
            nuke[nukeCount++] = body1;
        }
        else
        {
            nuke[nukeCount++] = body2;
        }

        if (nukeCount == k_maxNuke)
        {
            break;
        }
    }
}

// Sort the nuke array to group duplicates.
std::sort(nuke, nuke + nukeCount);

// Destroy the bodies, skipping duplicates.
int32 i = 0;
while (i &lt; nukeCount)
{
    b2Body* b = nuke[i++];
    while (i &lt; nukeCount &amp;&amp; nuke[i] == b)
    {
        ++i;
    }

    m_world-&gt;DestroyBody(b);
}
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1469"></a>9.3.&nbsp;Contact Filtering</h2></div></div></div><p>Often in a game you don't want all objects to collide. For example, you may want to create a door that only certain characters can pass through. This is called contact filtering, because some interactions are <span class="emphasis"><em>filtered out</em></span>.</p><p>Box2D allows you to achieve custom contact filtering by implementing a <tt class="classname">b2ContactFilter</tt> class. This class requires you to implement a <tt class="methodname">ShouldCollide</tt> function that receives two <tt class="classname">b2Shape</tt> pointers. Your function returns true if the shapes should collide.</p><p>The default implementation of <tt class="methodname">ShouldCollide</tt> uses the <span class="structname">b2FilterData</span> defined in <a href="#fixtures" title="Chapter&nbsp;7.&nbsp;Fixtures">Chapter&nbsp;7, <i>Fixtures</i></a>.</p><pre class="programlisting">
bool b2ContactFilter::ShouldCollide(b2Shape* shape1, b2Shape* shape2)
{
	const b2FilterData&amp; filter1 = shape1-&gt;GetFilterData();
	const b2FilterData&amp; filter2 = shape2-&gt;GetFilterData();

	if (filter1.groupIndex == filter2.groupIndex &amp;&amp; filter1.groupIndex != 0)
	{
		return filter1.groupIndex &gt; 0;
	}

	bool collide = (filter1.maskBits &amp; filter2.categoryBits) != 0 &amp;&amp; (filter1.categoryBits &amp; filter2.maskBits) != 0;
	return collide;
}
</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e1500"></a>Chapter&nbsp;10.&nbsp;Loose Ends</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#world_boundary">10.1. World Boundary</a></span></dt><dt><span class="sect1"><a href="#implicit_destruction">10.2. Implicit Destruction</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="world_boundary"></a>10.1.&nbsp;World Boundary</h2></div></div></div><p>You can implement a <tt class="classname">b2BoundaryListener</tt> that allows <tt class="classname">b2World</tt> to inform you when a body has gone outside the world AABB. When you get the callback, you shouldn't try to delete the body, instead you should mark the parent actor for deletion or error handling. After the physics time step, you should handle the event.</p><pre class="programlisting">
class MyBoundaryListener : public b2BoundaryListener
{
    void Violation(b2Body* body)
    {
        MyActor* myActor = (MyActor*)body-&gt;GetUserData();
        myActor-&gt;MarkForErrorHandling();
    }
};</pre><p>You can then register an instance of your boundary listener with your world object. You should do this during world initialization.</p><pre class="programlisting">
        myWorld-&gt;SetListener(myBoundaryListener);</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="implicit_destruction"></a>10.2.&nbsp;Implicit Destruction</h2></div></div></div><p>Box2D doesn't use reference counting. So if you destroy a body it is really gone. Accessing a pointer to a destroyed body has undefined behavior. In other words, your program will likely crash and burn. To help fix these problems, the debug build memory manager fills destroyed entities with <tt class="literal">FDFDFDFD</tt>. This can help find problems more easily in some cases.</p><p>If you destroy a Box2D entity, it is up to you to make sure you remove all references to the destroyed object. This is easy if you only have a single reference to the entity. If you have multiple references, you might consider implementing a <span class="emphasis"><em>handle</em></span> class to wrap the raw pointer.</p><p>Often when using Box2D you will create and destroy many bodies, shapes, and joints. Managing these entities is somewhat automated by Box2D. If you destroy a body then all associated shapes and joints are automatically destroyed. This is called <span class="emphasis"><em>implicit destruction</em></span>.</p><p>When you destroy a body, all its attached shapes, joints, and contacts are destroyed. This is called <span class="emphasis"><em>implicit destruction</em></span>. Any body connected to one of those joints and/or contacts is woken. This process is usually convenient. However, you must be aware of one crucial issue:</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>When a body is destroyed, all shapes and joints attached to the body are automatically destroyed. You must nullify any pointers you have to those shapes and joints. Otherwise, your program will <span class="emphasis"><em>die horribly</em></span> if you try to access or destroy those shapes or joints later.</p></div><p>To help you nullify your joint pointers, Box2D provides a listener class named <tt class="classname">b2WorldListener</tt> that you can implement and provide to your world object. Then the world object will notify you when a joint is going to be implicity destroyed.</p><p>Implicit destruction is a great convenience in many cases. It can also make your program fall apart. You may store pointers to shapes and joints somewhere in your code. These pointers become orphaned when an associated body is destroyed. The situation becomes worse when you consider that joints are often created by a part of the code unrelated to management of the associated body. For example, the testbed creates a <tt class="classname">b2MouseJoint</tt> for interactive manipulation of bodies on the screen.</p><p>Box2D provides a callback mechanism to inform your application when implicit destruction occurs. This gives your application a chance to nullify the orphaned pointers. This callback mechanism is described later in this manual.</p><p>You can implement a <tt class="classname">b2DestructionListener</tt> that allows <tt class="classname">b2World</tt> to inform you when a shape or joint is implicitly destroyed because an associated body was destroyed. This will help prevent your code from accessing orphaned pointers.</p><pre class="programlisting">
class MyDestructionListener : public b2DestructionListener
{
    void SayGoodbye(b2Joint* joint)
    {
        // remove all references to joint.
    }
};</pre><p>You can then register an instance of your destruction listener with your world object. You should do this during world initialization.</p><pre class="programlisting">
myWorld-&gt;SetListener(myDestructionListener);</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e1575"></a>Chapter&nbsp;11.&nbsp;Settings</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e1578">11.1. About</a></span></dt><dt><span class="sect1"><a href="#d0e1591">11.2. Tolerances</a></span></dt><dt><span class="sect1"><a href="#d0e1598">11.3. Memory Allocation</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1578"></a>11.1.&nbsp;About</h2></div></div></div><p>There are two source files included in Box2D that are supplied specifically for user customization. These are <tt class="filename">b2Settings.h</tt> and <tt class="filename">b2Settings.cpp</tt>.</p><p>Box2D works with floating point numbers, so some tolerances have to be used to make Box2D perform well.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1591"></a>11.2.&nbsp;Tolerances</h2></div></div></div><p>There are many tolerances settings that depend on using MKS units. See <a href="#units" title="3.3.&nbsp;Units">Section&nbsp;3.3, &#8220;Units&#8221;</a> for a deeper explanation of the unit system. See the doxygen docs for explanation of the individual tolerances.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1598"></a>11.3.&nbsp;Memory Allocation</h2></div></div></div><p>All of Box2D's memory allocations are funnelled through <tt class="function">b2Alloc</tt> and <tt class="function">b2Free</tt> except in the following cases.</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">b2World</tt> can be built on the stack or with whatever allocator you like.</p></li><li><p>Any other Box2D class that you create without using a factory method. This includes things like callbacks classes and contact point buffers.</p></li></ul></div><p>Feel free to redirect the allocation by modifying <tt class="filename">b2Settings.cpp</tt>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e1623"></a>Chapter&nbsp;12.&nbsp;Debug Drawing</h2></div></div></div><p>You can implement the <tt class="classname">b2DebugDraw</tt> class to get detailed drawing of the physics world.
    Here are the available entities:</p><div class="itemizedlist"><ul type="disc"><li><p>shape outlines</p></li><li><p>joint connectivity</p></li><li><p>core shapes (for continuous collision)</p></li><li><p>broad-phase axis-aligned bounding boxes (AABBs), including the world AABB</p></li><li><p>polygon oriented bounding boxes (OBBs)</p></li><li><p>broad-phase pairs (potential contacts)</p></li><li><p>center of mass</p></li></ul></div><p>This the preferred method of drawing these physics entities, rather than accessing the data directly. The reason is that much of the necessary data is internal and subject to change.</p><p>The testbed draws physics entities using the debug draw facility and the contact listener, so it serves as the primary example of how to implement debug drawing as well as how to draw contact points.</p><div class="screenshot"><div class="mediaobject"><img src="images/debugDraw.gif"></div></div></div></div></body></html>